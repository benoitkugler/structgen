package crud

import (
	"bytes"
	"fmt"
	"go/types"

	"github.com/benoitkugler/structgen/loader"
	"github.com/benoitkugler/structgen/orm"
)

var _ loader.Handler = &handler{} // interface conformity

type StructSQL struct {
	orm.GoSQLTable
}

type StructSQLTest struct {
	orm.GoSQLTable
}

func (m StructSQL) Render() []loader.Declaration {
	args := m.GoSQLTable

	tmpl := templateStructLink
	if args.HasID() {
		tmpl = templateStructWithID
	}

	var out bytes.Buffer
	if err := templateScan.Execute(&out, args); err != nil {
		panic(err)
	}
	if err := tmpl.Execute(&out, args); err != nil {
		panic(err)
	}

	return []loader.Declaration{{Id: m.Id(), Content: out.String()}}
}

func (m StructSQLTest) Render() []loader.Declaration {
	args := m.GoSQLTable
	var out bytes.Buffer
	if err := templateTest.Execute(&out, args); err != nil {
		panic(err)
	}

	return []loader.Declaration{{Id: m.Id(), Content: out.String()}}
}

type handler struct {
	PackageName string

	uniqueConstraints map[string][]string // table name -> unique cols
	tables            []StructSQL

	IsTest bool
}

func NewHandler(packageName string, isTest bool) *handler {
	return &handler{PackageName: packageName, IsTest: isTest, uniqueConstraints: make(map[string][]string)}
}

func (l handler) Header() string {
	var dbInterface string
	if !l.IsTest {
		dbInterface = `

		type scanner interface {
			Scan(...interface{}) error
		}

		// DB groups transaction like objects
		type DB interface {
			Exec(query string, args ...interface{}) (sql.Result, error)
			Query(query string, args ...interface{}) (*sql.Rows, error)
			QueryRow(query string, args ...interface{}) *sql.Row 
			Prepare(query string) (*sql.Stmt, error)
		}`
	}

	return fmt.Sprintf(`
	// DON'T EDIT - automatically generated by structgen //

	package %s

	import "database/sql"

	%s
	`, l.PackageName, dbInterface)
}

func (l handler) Footer() string {
	var out bytes.Buffer
	for _, table := range l.tables {
		table.SetUniqueColumns(l.uniqueConstraints)
		if err := templateSelectBy.Execute(&out, table); err != nil {
			panic(err)
		}
		if table.HasID() { // the lookup methods are only valid for link tables
			continue
		}
		if err := templateStructLinkToLookup.Execute(&out, table); err != nil {
			panic(err)
		}
	}
	return out.String()
}

func (l *handler) HandleType(typ types.Type) loader.Type {
	item, isTable := orm.TypeToSQLStruct(typ, nil)
	if !isTable {
		return nil
	}
	var decl loader.Type
	if l.IsTest {
		decl = StructSQLTest{item}
	} else {
		table := StructSQL{item}
		l.tables = append(l.tables, table)
		decl = table
	}
	return decl
}

func (l handler) HandleComment(comment loader.Comment) error {
	if comment.Tag != "sql" { // ignored
		return nil
	}
	column := orm.IsUniqueConstraint(comment)
	if column != "" { // we have a unique field
		l.uniqueConstraints[comment.TypeName] = append(l.uniqueConstraints[comment.TypeName], column)
	}
	return nil
}
