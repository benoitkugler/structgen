package crud

import (
	"bytes"
	"fmt"
	"go/types"
	"io"

	"github.com/benoitkugler/structgen/loader"
	"github.com/benoitkugler/structgen/orm"
)

var _ loader.Handler = &Handler{} // interface conformity

type StructSQL struct {
	orm.GoSQLTable
}

type StructSQLTest struct {
	orm.GoSQLTable
}

func (m StructSQL) Render() string {
	args := m.GoSQLTable

	tmpl := templateStructLink
	if args.HasID() {
		tmpl = templateStructWithID
	}

	var out bytes.Buffer
	if err := templateScan.Execute(&out, args); err != nil {
		panic(err)
	}
	if err := tmpl.Execute(&out, args); err != nil {
		panic(err)
	}

	return out.String()
}

func (m StructSQLTest) Render() string {
	args := m.GoSQLTable
	var out bytes.Buffer
	if err := templateTest.Execute(&out, args); err != nil {
		panic(err)
	}
	return out.String()
}

type Handler struct {
	PackageName string
	IsTest      bool

	tables            []StructSQL
	uniqueConstraints map[string][]string // table name -> unique cols
}

func NewHandler(packageName string, isTest bool) *Handler {
	return &Handler{PackageName: packageName, IsTest: isTest, uniqueConstraints: make(map[string][]string)}
}

func (l Handler) WriteHeader(w io.Writer) error {
	var dbInterface string
	if !l.IsTest {
		dbInterface = `

		type scanner interface {
			Scan(...interface{}) error
		}

		// DB groups transaction like objects
		type DB interface {
			Exec(query string, args ...interface{}) (sql.Result, error)
			Query(query string, args ...interface{}) (*sql.Rows, error)
			QueryRow(query string, args ...interface{}) *sql.Row 
			Prepare(query string) (*sql.Stmt, error)
		}`
	}

	_, err := fmt.Fprintf(w, `
	// DON'T EDIT - automatically generated by structgen //

	package %s

	import "database/sql"

	%s
	`, l.PackageName, dbInterface)
	return err
}
func (l Handler) WriteFooter(w io.Writer) error {
	for _, table := range l.tables {
		table.SetUniqueColumns(l.uniqueConstraints)
		if err := templateSelectBy.Execute(w, table); err != nil {
			return err
		}
		if table.HasID() { // the lookup methods are only valid for link tables
			continue
		}
		if err := templateStructLinkToLookup.Execute(w, table); err != nil {
			return err
		}
	}
	return nil
}

func (l *Handler) HandleType(topLevelDecl *loader.Declarations, typ types.Type) {
	item, isTable := orm.TypeToSQLStruct(typ, nil)
	if !isTable {
		return
	}
	var decl loader.Declaration
	if l.IsTest {
		decl = StructSQLTest{item}
	} else {
		table := StructSQL{item}
		l.tables = append(l.tables, table)
		decl = table
	}
	topLevelDecl.Add(decl)
}

func (l Handler) HandleComment(topLevelDecl *loader.Declarations, comment loader.Comment) error {
	if comment.Tag != "sql" { // ignored
		return nil
	}
	column := orm.IsUniqueConstraint(comment)
	if column != "" { // we have a unique field
		l.uniqueConstraints[comment.TypeName] = append(l.uniqueConstraints[comment.TypeName], column)
	}
	return nil
}
