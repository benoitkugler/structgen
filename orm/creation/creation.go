package creation

import (
	"fmt"
	"go/types"
	"io"
	"strings"

	"github.com/benoitkugler/structgen/enums"
	"github.com/benoitkugler/structgen/loader"
	"github.com/benoitkugler/structgen/orm"
)

func NewGenHandler(enumsTable enums.EnumTable) loader.Handler {
	return &sqlGenHandler{enumsTable: enumsTable, lookupEnumTable: enumsTable.AsLookupTable()}
}

type TableGen struct {
	orm.GoSQLTable
	enumsTable enums.EnumTable
}

func (t TableGen) Id() string {
	return t.Name
}

func (t TableGen) Render() string {
	fieldsDecl := make([]string, len(t.Fields))
	fieldsName := make([]string, len(t.Fields))
	for i, f := range t.Fields {
		fieldsDecl[i] = "\t" + f.CreateStmt(t.enumsTable)
		fieldsName[i] = f.SQLName
	}
	return fmt.Sprintf(`
CREATE TABLE %s (
%s
);`, t.TableName(), strings.Join(fieldsDecl, ",\n"))
}

// func (t TableGen) addDeclarations(l *loader.Declarations) {
// 	for _, f :=range t.Fields {
// 	}
// }

// encode constraints we want to defer
type constraint interface {
	Render() string
}

type sqlGenHandler struct {
	constraints     []constraint
	enumsTable      enums.EnumTable
	lookupEnumTable map[string]string // cached from `enumsTable`
}

func (l sqlGenHandler) WriteHeader(w io.Writer) error {
	_, err := fmt.Fprint(w, `
	-- DO NOT EDIT - autogenerated by structgen 
		   
	`)
	return err
}

func (l sqlGenHandler) WriteFooter(w io.Writer) error {
	chunks := make([]string, 0, len(l.constraints))
	for _, c := range l.constraints {
		chunks = append(chunks, c.Render())
	}
	_, err := fmt.Fprintln(w, strings.Join(chunks, "\n"))
	return err
}

func (l *sqlGenHandler) HandleType(topLevelDecl *loader.Declarations, typ types.Type) {
	table, isTable := orm.TypeToSQLStruct(typ)
	if !isTable {
		return
	}
	decl := TableGen{GoSQLTable: table, enumsTable: l.enumsTable}
	topLevelDecl.Add(decl)
	for _, f := range table.Fields {
		foreignConstraint, has := f.ForeignConstraint(decl.Name)
		if has {
			l.constraints = append(l.constraints, foreignConstraint)
		}
	}
}

func (l *sqlGenHandler) HandleComment(topLevelDecl *loader.Declarations, comment loader.Comment) error {
	switch comment.Tag {
	case "sql":
	case "noTableSql":
		comment.TypeName = ""
	default:
		return nil
	}
	ct, err := orm.NewConstraint(comment, l.lookupEnumTable)
	l.constraints = append(l.constraints, ct)
	return err
}
