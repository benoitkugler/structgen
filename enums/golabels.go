package enums

import (
	"bytes"
	"fmt"
	"go/types"
	"io"
	"log"
	"sort"
	"text/template"

	"github.com/benoitkugler/structgen/loader"
)

var (
	tmplInt = template.Must(template.New("labels_int").Parse(`
		{{ .Name }}Labels = [...]string{
			{{ range .Values -}}
				{{ .VarName }}: "{{ .Label }}",
			{{ end -}}
		}`))

	tmplDefault = template.Must(template.New("labels").Parse(`
		{{ .Name }}Labels = map[{{ .Name }}]string{
			{{ range .Values -}}
				{{ .VarName }}: "{{ .Label }}",
			{{ end -}}
		}`))
)

// labels returns the code for
// mapping variable
func (e EnumType) labels() string {
	var out bytes.Buffer
	tmpl := tmplDefault
	if e.isInt {
		tmpl = tmplInt
	}
	if err := tmpl.Execute(&out, e); err != nil {
		log.Fatal(err)
	}
	return out.String()
}

type Handler struct {
	PackageName string
	Enums       EnumTable
}

func (d Handler) HandleType(topLevelDecl *loader.Declarations, typ types.Type) {}
func (d Handler) HandleComment(topLevelDecl *loader.Declarations, comment loader.Comment) error {
	return nil
}

func (d Handler) WriteHeader(w io.Writer) error {
	_, err := fmt.Fprintf(w, "package %s \n // DO NOT EDIT - autogenerated from enums.go \n\n  var ( \n ", d.PackageName)
	if err != nil {
		return err
	}

	// print in deterministic order
	var keys []string
	for key := range d.Enums {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	for _, key := range keys {
		_, err = fmt.Fprintln(w, d.Enums[key].labels())
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprintln(w, ")")
	return err
}
func (d Handler) WriteFooter(w io.Writer) error { return nil }
