package test

import "encoding/json"

// Code generated by structgen/interfaces. DO NOT EDIT
	
func union1UnmarshalJSON(src []byte) (union1, error) {
	type wrapper struct {
		Data json.RawMessage
		Kind int
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return nil, err
	}
	switch wr.Kind {
	case 0:
		var out member1
		err = json.Unmarshal(wr.Data, &out)
		return out, err
	case 1:
		var out member2
		err = json.Unmarshal(wr.Data, &out)
		return out, err
	case 2:
		var out member3
		err = json.Unmarshal(wr.Data, &out)
		return out, err

	default:
		panic("exhaustive switch")
	}
}

func union1MarshalJSON(item union1) ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind int
	}
	var out wrapper
	switch item.(type) {
	case member1:
		out = wrapper{Kind: 0, Data: item}
	case member2:
		out = wrapper{Kind: 1, Data: item}
	case member3:
		out = wrapper{Kind: 2, Data: item}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(out)
}

func union2UnmarshalJSON(src []byte) (union2, error) {
	type wrapper struct {
		Data json.RawMessage
		Kind int
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return nil, err
	}
	switch wr.Kind {
	case 0:
		var out member1
		err = json.Unmarshal(wr.Data, &out)
		return out, err

	default:
		panic("exhaustive switch")
	}
}

func union2MarshalJSON(item union2) ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind int
	}
	var out wrapper
	switch item.(type) {
	case member1:
		out = wrapper{Kind: 0, Data: item}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(out)
}
	
